name: Notifications

on:
  workflow_run:
    workflows:
      - Code Quality & Security
      - Integrated CI/CD Pipeline
      - Semantic Release
      - Master Environment Pipeline
      - CI + E2E + Locust + Pages
    types:
      - completed
    branches:
      - main
      - master

env:
  # Webhook Slack (tomado de secrets para entorno real)
  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

jobs:
  notify:
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      checks: read
    steps:
      - name: Set status
        id: status
        run: |
          if [ "${{ github.event.workflow_run.conclusion }}" = "success" ]; then
            echo "status=PASSED" >> $GITHUB_OUTPUT
          else
            echo "status=FAILED" >> $GITHUB_OUTPUT
          fi

      - name: Descargar y extraer logs (solo si falla)
        if: steps.status.outputs.status == 'FAILED'
        continue-on-error: true
        env:
          RUN_ID: ${{ github.event.workflow_run.id }}
        run: |
          echo "Descargando logs para run ID: $RUN_ID"
          # Usar la API de GitHub Actions para descargar logs
          HTTP_CODE=$(curl -L \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ github.token }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -w "%{http_code}" \
            -o logs.zip \
            -s \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/$RUN_ID/logs")
          
          echo "HTTP Status Code: $HTTP_CODE"
          
          # Verificar que el archivo descargado es un ZIP válido
          if [ ! -f logs.zip ] || [ "$HTTP_CODE" != "200" ]; then
            echo "Advertencia: No se pudo descargar logs.zip (HTTP $HTTP_CODE)"
            if [ -f logs.zip ]; then
              echo "Contenido de la respuesta:"
              head -c 500 logs.zip
              echo ""
            fi
            mkdir -p logs
            echo "No se pudieron descargar los logs del workflow (HTTP $HTTP_CODE)." > logs/error.txt
            exit 0
          fi
          
          # Verificar que es un archivo ZIP válido
          if ! file logs.zip | grep -q "Zip archive"; then
            echo "Advertencia: El archivo descargado no es un ZIP válido. Contenido:"
            head -c 500 logs.zip
            echo ""
            echo "Intentando continuar sin logs..."
            mkdir -p logs
            echo "No se pudieron descargar los logs del workflow (archivo no válido)." > logs/error.txt
            exit 0
          fi
          
          # Extraer logs
          unzip -q logs.zip -d logs || {
            echo "Error al extraer logs.zip. Intentando continuar..."
            mkdir -p logs
            echo "Error al extraer logs del archivo ZIP." > logs/error.txt
          }
          
          echo "Archivos de log extraídos:" && ls -1 logs | head -n 20

      - name: Generar snippet de fallos
        if: steps.status.outputs.status == 'FAILED'
        id: snippet
        run: |
          # Asegurar que el directorio logs existe
          mkdir -p logs distilled
          
          # Buscar patrones comunes de error en todos los .txt
          MAX_LINES=200
          PATTERN='ERROR|Error|FAIL|Fail|::error|error:|Exception|Exception:'
          
          # Buscar errores en todos los archivos de log
          if [ -d logs ] && [ "$(ls -A logs/*.txt 2>/dev/null)" ]; then
            for f in logs/*.txt; do
              if [ -f "$f" ]; then
                grep -E "$PATTERN" "$f" | head -n $MAX_LINES >> distilled/failures.txt || true
              fi
            done
          fi
          
          if [ -f distilled/failures.txt ] && [ -s distilled/failures.txt ]; then
            # Limitar tamaño (Slack/Teams)
            head -c 8000 distilled/failures.txt > distilled/failures_truncated.txt
            echo 'found=true' >> $GITHUB_OUTPUT
            # Guardar snippet en archivo y codificar en base64 para evitar problemas con caracteres especiales
            SNIPPET_B64=$(base64 -w 0 < distilled/failures_truncated.txt)
            echo "$SNIPPET_B64" > snippet_b64.txt
            # Usar delimitador multiline para evitar problemas con caracteres especiales
            {
              echo 'snippet<<SNIPPET_EOF'
              cat snippet_b64.txt
              echo 'SNIPPET_EOF'
            } >> $GITHUB_OUTPUT
          else
            echo 'found=false' >> $GITHUB_OUTPUT
            SNIPPET_MSG="No se pudieron obtener los logs del workflow. Ver detalles en: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }}"
            SNIPPET_B64=$(echo -n "$SNIPPET_MSG" | base64 -w 0)
            {
              echo 'snippet<<SNIPPET_EOF'
              echo "$SNIPPET_B64"
              echo 'SNIPPET_EOF'
            } >> $GITHUB_OUTPUT
          fi

      - name: Slack notification (from secret)
        if: always() && env.SLACK_WEBHOOK_URL != ''
        uses: slackapi/slack-github-action@v1.27.0
        with:
          payload: |
            {
              "text": "Workflow '${{ github.event.workflow_run.name }}' ${{ steps.status.outputs.status }} en ${{ github.repository }}@${{ github.ref_name }}.",
              "blocks": [
                {
                  "type": "section",
                  "text": {"type": "mrkdwn", "text": "*${{ github.event.workflow_run.name }}* finalizado con *${{ steps.status.outputs.status }}*\nRepositorio: ${{ github.repository }}\nBranch: ${{ github.ref_name }}\nActor: ${{ github.actor }}\nRun: <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }}|Ver ejecución>"}
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ env.SLACK_WEBHOOK_URL }}
        continue-on-error: true

      - name: Enviar snippet separado a Slack si falló
        if: steps.status.outputs.status == 'FAILED' && env.SLACK_WEBHOOK_URL != ''
        run: |
          # Decodificar el snippet de base64
          SNIPPET_DECODED=$(echo "${{ steps.snippet.outputs.snippet }}" | base64 -d)
          # Escapar para JSON usando jq
          SNIPPET_JSON=$(echo -n "$SNIPPET_DECODED" | jq -Rs .)
          PAYLOAD=$(jq -Rn \
            --arg t "${{ github.event.workflow_run.name }}" \
            --arg s "${{ steps.status.outputs.status }}" \
            --arg repo "${{ github.repository }}" \
            --arg branch "${{ github.ref_name }}" \
            --arg actor "${{ github.actor }}" \
            --argjson snippet "$SNIPPET_JSON" \
            '{text: ($t + " " + $s + " en " + $repo + "@" + $branch + " por " + $actor + "\nSnippet de errores:\n```" + $snippet + "```")}')
          curl -X POST -H 'Content-type: application/json' --data "$PAYLOAD" "$SLACK_WEBHOOK_URL"
