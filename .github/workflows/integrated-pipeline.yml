
name: Integrated CI/CD Pipeline

on:
  push:
    branches: [ main, master, develop, stage, staging, FEAT/-Notifications-to-teams-and-slack, FEAT/-SonarQube_And_Trivy ]
  pull_request:
    branches: [ main, master, develop, stage, FEAT/-Notifications-to-teams-and-slack, FEAT/-SonarQube_And_Trivy ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'stage'
        type: choice
        options:
          - dev
          - stage
          - prod

permissions:
  contents: read
  security-events: write
  checks: write
  packages: write

env:
  JAVA_VERSION: '11'
  MAVEN_OPTS: '-Xmx3072m'
  REGISTRY: ghcr.io
  REPO_NAME_LOWER: ${{ github.event.repository.name }}
  IMAGE_PREFIX: ${{ github.repository_owner }}/${{ github.event.repository.name }}
  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
  ISSUE_TOKEN: ${{ secrets.ISSUE_TOKEN }}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ==================== JOB 1: SECURITY SCAN (Trivy) ====================
  security-scan:
    name: Security Scan (Trivy)
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        service:
          - product-service
          - user-service
          - payment-service
          - order-service
          - shipping-service
          - favourite-service
          - api-gateway
          - cloud-config
          - service-discovery
          - proxy-client
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2-

      - name: Build JAR
        run: |
          cd ${{ matrix.service }}
          ../mvnw clean package -DskipTests

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'maven'

      - name: Run OWASP Dependency-Check
        continue-on-error: true
        run: |
          echo "Running OWASP Dependency-Check for ${{ matrix.service }}..."
          ./mvnw org.owasp:dependency-check-maven:check \
            -pl ${{ matrix.service }} \
            -am \
            -DfailBuildOnCVSS=0 \
            -DautoUpdate=true \
            -Dformat=HTML \
            -Dformat=JSON \
            -Dformat=XML || echo "OWASP scan completed with vulnerabilities"
        env:
          JAVA_OPTS: "-Xmx2048m"

      - name: Upload OWASP Reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: owasp-report-${{ matrix.service }}
          path: ${{ matrix.service }}/target/dependency-check-report.*
          retention-days: 30

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '${{ matrix.service }}/target'
          format: 'sarif'
          output: 'trivy-results-${{ matrix.service }}.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: 'trivy-results-${{ matrix.service }}.sarif'

      - name: Scan Dockerfile
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '${{ matrix.service }}/Dockerfile'
          format: 'table'
          exit-code: '1'
          severity: 'CRITICAL,HIGH'

  # ==================== JOB 2: UNIT & INTEGRATION TESTS ====================
  unit-integration-tests:
    name: Unit & Integration Tests
    runs-on: ubuntu-latest
    needs: [security-scan]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2-

      - name: Run unit tests
        run: mvn -B test -Dtest="*Test" -DfailIfNoTests=false

      - name: Run integration tests
        run: mvn -B test -Dtest="*IntegrationTest" -DfailIfNoTests=false

      - name: Publish Test Results
        uses: EnricoMi/publish-unit-test-result-action@v2
        if: always()
        with:
          files: '**/target/surefire-reports/TEST-*.xml'
          check_name: 'Test Results'

      - name: Generate Test Report
        if: always()
        run: |
          mkdir -p test-results
          mvn surefire-report:report-only -Daggregate=true || true
          echo "Test reports generated"

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: |
            **/target/surefire-reports/**
            **/target/site/surefire-report.html

  # ==================== JOB 3: BUILD DOCKER IMAGES ====================
  build-docker:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [unit-integration-tests]
    strategy:
      fail-fast: false
      matrix:
        service:
          - product-service
          - user-service
          - payment-service
          - order-service
          - shipping-service
          - favourite-service
          - api-gateway
          - cloud-config
          - service-discovery
          - proxy-client
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set repository name to lowercase
        id: repo-name
        run: |
          REPO_NAME_LOWER=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "REPO_NAME_LOWER=$REPO_NAME_LOWER" >> $GITHUB_ENV
          echo "repo_name_lower=$REPO_NAME_LOWER" >> $GITHUB_OUTPUT

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'maven'

      - name: Build JAR files
        run: ./mvnw clean package -DskipTests -pl ${{ matrix.service }} -am

      - name: Verify JAR file exists
        run: |
          JAR_FILE="${{ matrix.service }}/target/${{ matrix.service }}-v0.1.0.jar"
          if [ ! -f "$JAR_FILE" ]; then
            echo "Error: JAR file not found at $JAR_FILE"
            echo "Contents of ${{ matrix.service }}/target/:"
            ls -la "${{ matrix.service }}/target/" || echo "Target directory does not exist"
            exit 1
          fi
          echo "JAR file found: $JAR_FILE"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          logout: false

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ steps.repo-name.outputs.repo_name_lower }}/${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ matrix.service }}/Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
          build-args: |
            PROJECT_VERSION=0.1.0
          
      - name: List pushed image tags
        if: github.event_name != 'pull_request'
        run: |
          echo "Tags generated for ${{ matrix.service }}:"
          echo "${{ steps.meta.outputs.tags }}"
          echo ""
          echo "Full image name:"
          echo "${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ steps.repo-name.outputs.repo_name_lower }}/${{ matrix.service }}"

      - name: Build image for local scan
        uses: docker/build-push-action@v5
        if: github.event_name != 'pull_request'
        with:
          context: .
          file: ${{ matrix.service }}/Dockerfile
          push: false
          load: true
          tags: ${{ matrix.service }}:local-scan
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
          build-args: |
            PROJECT_VERSION=0.1.0

      - name: Scan image with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ matrix.service }}:local-scan
          format: 'sarif'
          output: 'trivy-image-${{ matrix.service }}.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'
        if: github.event_name != 'pull_request'

      - name: Upload Trivy image scan results
        uses: github/codeql-action/upload-sarif@v4
        if: always() && github.event_name != 'pull_request'
        with:
          sarif_file: 'trivy-image-${{ matrix.service }}.sarif'

  # ==================== JOB 4: E2E TESTS ====================
  e2e-tests:
    name: E2E Tests (K8s + Newman)
    runs-on: ubuntu-latest
    needs: [build-docker]
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install kubectl
        uses: azure/setup-kubectl@v4

      - name: Install kind
        uses: helm/kind-action@v1.10.0
        with:
          version: v0.23.0

      - name: Create kind cluster
        run: |
          kind create cluster --name e2e-test --wait 120s
          kubectl version --client

      - name: Set repository name to lowercase
        id: repo-name
        run: |
          REPO_NAME_LOWER=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "REPO_NAME_LOWER=$REPO_NAME_LOWER" >> $GITHUB_ENV
          echo "repo_name_lower=$REPO_NAME_LOWER" >> $GITHUB_OUTPUT

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull and load images into kind
        run: |
          set -e
          REPO_NAME_LOWER=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          
          # Lista de tags a intentar en orden de prioridad
          # El formato type=sha,prefix={{branch}}- genera: main-<sha>
          # type=ref,event=branch genera: main
          TAGS_TO_TRY=(
            "${{ github.ref_name }}-${{ github.sha }}"
            "main-${{ github.sha }}"
            "${{ github.ref_name }}"
            "main"
          )
          
          for service in product-service user-service payment-service order-service shipping-service favourite-service api-gateway cloud-config service-discovery proxy-client; do
            IMAGE_BASE="${{ env.REGISTRY }}/${{ github.repository_owner }}/$REPO_NAME_LOWER/$service"
            IMAGE_TAG=""
            PULLED=false
            
            echo "=== Attempting to pull $service ==="
            for tag in "${TAGS_TO_TRY[@]}"; do
              FULL_TAG="${IMAGE_BASE}:${tag}"
              echo "Trying tag: $FULL_TAG"
              if docker pull "$FULL_TAG" 2>/dev/null; then
                IMAGE_TAG="$FULL_TAG"
                PULLED=true
                echo "âœ“ Successfully pulled: $FULL_TAG"
                break
              else
                echo "âœ— Failed to pull: $FULL_TAG"
              fi
            done
            
            if [ "$PULLED" = false ]; then
              echo "ERROR: Failed to pull $service with any of the attempted tags"
              echo "Available tags in registry (if any):"
              # Intentar listar tags disponibles (puede fallar si no hay permisos)
              curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                "https://ghcr.io/v2/${{ github.repository_owner }}/$REPO_NAME_LOWER/$service/tags/list" | jq -r '.tags[]' 2>/dev/null | head -10 || echo "Could not list tags"
              exit 1
            fi
            
            echo "Loading image into kind: $IMAGE_TAG"
            if kind load docker-image "$IMAGE_TAG" --name e2e-test; then
              echo "âœ“ Successfully loaded $service"
            else
              echo "ERROR: Failed to load $IMAGE_TAG into kind"
              exit 1
            fi
          done
          
          echo "=== Verifying images in kind ==="
          docker exec e2e-test-control-plane crictl images | grep -E "(product-service|user-service|api-gateway)" || true

      - name: Update Kubernetes manifests with correct images
        run: |
          set -e
          REPO_NAME_LOWER=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "Replacing images in Kubernetes manifests..."
          echo "Repository: $REPO_NAME_LOWER"
          echo "Tag: ${{ github.ref_name }}-${{ github.sha }}"
          
          # Reemplazar imÃ¡genes en los manifests
          for service in product-service user-service shipping-service payment-service order-service favourite-service api-gateway cloud-config service-discovery proxy-client; do
            OLD_IMAGE="selimhorri/${service}-ecommerce-boot:0.1.0"
            NEW_IMAGE="${{ env.REGISTRY }}/${{ github.repository_owner }}/$REPO_NAME_LOWER/${service}:${{ github.ref_name }}-${{ github.sha }}"
            echo "Replacing $OLD_IMAGE -> $NEW_IMAGE"
            find k8s -name "*.yaml" -type f -not -path "*/security/*" -exec sed -i "s|${OLD_IMAGE}|${NEW_IMAGE}|g" {} \;
          done
          
          echo "Verifying image replacements..."
          grep -r "ghcr.io" k8s/*.yaml | head -5 || true

      - name: Apply Kubernetes manifests
        run: |
          kubectl apply -k k8s
          kubectl get ns ecommerce || kubectl create ns ecommerce

      - name: Check pod status and diagnose issues
        run: |
          set -e
          echo "=== Checking initial pod status ==="
          kubectl -n ecommerce get pods -o wide
          
          echo "=== Waiting for pods to be created (30s) ==="
          sleep 30
          
          echo "=== Checking pod status after sleep ==="
          kubectl -n ecommerce get pods -o wide
          
          echo "=== Checking events ==="
          kubectl -n ecommerce get events --sort-by='.lastTimestamp' | tail -20
          
          echo "=== Checking pods in detail ==="
          for pod in $(kubectl -n ecommerce get pods -o jsonpath='{.items[*].metadata.name}'); do
            echo "--- Pod: $pod ---"
            kubectl -n ecommerce describe pod "$pod" | grep -A 10 "Events:" || true
            kubectl -n ecommerce describe pod "$pod" | grep -A 5 "Status:" || true
            echo ""
          done

      - name: Wait for deployments Ready
        run: |
          set -e
          echo "=== Waiting for deployments to be available ==="
          # Esperar hasta 600s por todos los deployments
          kubectl -n ecommerce wait --for=condition=available --timeout=600s deployment --all || {
            echo "=== Some deployments failed to become available ==="
            kubectl -n ecommerce get deployments -o wide
            kubectl -n ecommerce get pods -o wide
            kubectl -n ecommerce get events --sort-by='.lastTimestamp' | tail -30
            # Mostrar logs de pods que fallaron
            for pod in $(kubectl -n ecommerce get pods -o jsonpath='{.items[?(@.status.phase!="Running")].metadata.name}'); do
              echo "=== Logs for failed pod: $pod ==="
              kubectl -n ecommerce logs "$pod" --tail=50 || true
              kubectl -n ecommerce describe pod "$pod" | tail -30 || true
            done
            exit 1
          }
          
          echo "=== Waiting for pods to be ready ==="
          # Y esperar hasta 600s por todos los pods Ready
          kubectl -n ecommerce wait --for=condition=ready --timeout=600s pod --all || {
            echo "=== Some pods failed to become ready ==="
            kubectl -n ecommerce get pods -o wide
            kubectl -n ecommerce get events --sort-by='.lastTimestamp' | tail -30
            # Mostrar logs de pods que no estÃ¡n ready
            for pod in $(kubectl -n ecommerce get pods -o jsonpath='{.items[?(@.status.conditions[?(@.type=="Ready")].status!="True")].metadata.name}'); do
              echo "=== Logs for not-ready pod: $pod ==="
              kubectl -n ecommerce logs "$pod" --tail=50 || true
              kubectl -n ecommerce describe pod "$pod" | tail -30 || true
            done
            exit 1
          }
          
          echo "=== All pods are ready ==="
          kubectl -n ecommerce get pods -o wide

      - name: Port-forward services to localhost
        run: |
          set -e
          # Obtiene el primer pod por etiqueta app
          pod_of() { kubectl -n "$1" get pod -l app="$2" -o jsonpath='{.items[0].metadata.name}'; }

          P_PRODUCT=$(pod_of ecommerce product-service)
          P_USER=$(pod_of ecommerce user-service)
          P_SHIP=$(pod_of ecommerce shipping-service)
          P_PAY=$(pod_of ecommerce payment-service)
          P_ORDER=$(pod_of ecommerce order-service)
          P_FAV=$(pod_of ecommerce favourite-service)

          echo "PF -> product-service: $P_PRODUCT, user-service: $P_USER, shipping: $P_SHIP, payment: $P_PAY, order: $P_ORDER, favourite: $P_FAV"

          # Lanzar port-forwards a pods en background
          nohup kubectl -n ecommerce port-forward pod/$P_PRODUCT 8500:8500 >/dev/null 2>&1 & echo $! > pf_product.pid
          nohup kubectl -n ecommerce port-forward pod/$P_USER 8700:8700 >/dev/null 2>&1 & echo $! > pf_user.pid
          nohup kubectl -n ecommerce port-forward pod/$P_SHIP 8600:8600 >/dev/null 2>&1 & echo $! > pf_shipping.pid
          nohup kubectl -n ecommerce port-forward pod/$P_PAY 8400:8400 >/dev/null 2>&1 & echo $! > pf_payment.pid
          nohup kubectl -n ecommerce port-forward pod/$P_ORDER 8300:8300 >/dev/null 2>&1 & echo $! > pf_order.pid
          nohup kubectl -n ecommerce port-forward pod/$P_FAV 8800:8800 >/dev/null 2>&1 & echo $! > pf_favourite.pid
          
          # Esperar un poco a que los port-forwards estÃ©n activos
          sleep 10

      - name: Warm-up and readiness checks (retry)
        run: |
          set -e
          retry() { for i in $(seq 1 24); do curl -fsS "$1" && echo "\nOK: $1" && return 0; echo "Retry $i: $1"; sleep 5; done; return 1; }

          if ! retry http://localhost:8500/product-service/api/products; then
            echo "DIAGNOSTICO: estado de product-service";
            kubectl -n ecommerce get svc product-service -o yaml || true
            kubectl -n ecommerce get endpoints product-service -o wide || true
            kubectl -n ecommerce get pod -l app=product-service -o wide || true
            P_PRODUCT=$(kubectl -n ecommerce get pod -l app=product-service -o jsonpath='{.items[0].metadata.name}' || true)
            [ -n "$P_PRODUCT" ] && kubectl -n ecommerce logs "$P_PRODUCT" --tail=200 || true
            exit 1
          fi

          if ! retry http://localhost:8700/user-service/api/users; then
            echo "DIAGNOSTICO: estado de user-service";
            kubectl -n ecommerce get pod -l app=user-service -o wide || true
            exit 1
          fi

          if ! retry http://localhost:8600/shipping-service/api/shippings; then
            echo "DIAGNOSTICO: estado de shipping-service";
            kubectl -n ecommerce get pod -l app=shipping-service -o wide || true
            exit 1
          fi

          if ! retry http://localhost:8400/payment-service/api/payments; then
            echo "DIAGNOSTICO: estado de payment-service";
            kubectl -n ecommerce get pod -l app=payment-service -o wide || true
            exit 1
          fi

          if ! retry http://localhost:8300/order-service/api/orders; then
            echo "DIAGNOSTICO: estado de order-service";
            kubectl -n ecommerce get pod -l app=order-service -o wide || true
            exit 1
          fi

          if ! retry http://localhost:8800/favourite-service/api/favourites; then
            echo "DIAGNOSTICO: estado de favourite-service";
            kubectl -n ecommerce get pod -l app=favourite-service -o wide || true
            exit 1
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Newman
        run: npm install -g newman

      - name: Run E2E tests
        run: |
          newman run tests/postman/ecommerce-e2e.postman_collection.json \
            --reporters cli,junit \
            --reporter-junit-export newman-results.xml

      - name: Upload E2E results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-results
          path: newman-results.xml

      - name: Cleanup port-forwards
        if: always()
        run: |
          for pidfile in pf_*.pid; do
            if [ -f "$pidfile" ]; then
              kill $(cat "$pidfile") 2>/dev/null || true
              rm -f "$pidfile"
            fi
          done
          pkill -f "kubectl.*port-forward" || true

      - name: Cleanup
        if: always()
        run: kind delete cluster --name e2e-test || true

  # ==================== JOB 5: DEPLOY TO STAGE (with approval) ====================
  deploy-stage:
    name: Deploy to Stage Environment
    runs-on: ubuntu-latest
    needs: [e2e-tests, build-docker]
    environment:
      name: stage
      url: https://stage.ecommerce.example.com
    if: github.ref == 'refs/heads/stage' || github.ref == 'refs/heads/staging' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'stage')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to Kubernetes (Stage)
        run: |
          echo "Deploying to stage environment..."
          # kubectl apply -k k8s -n stage

      - name: Health check
        run: |
          echo "Performing health checks..."

  # ==================== JOB 6: DEPLOY TO PROD (with approval) ====================
  deploy-prod:
    name: Deploy to Production Environment
    runs-on: ubuntu-latest
    needs: [deploy-stage]
    environment:
      name: production
      url: https://ecommerce.example.com
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to Kubernetes (Production)
        run: |
          echo "Deploying to production environment..."
          # kubectl apply -k k8s -n production

      - name: Health check
        run: |
          echo "Performing health checks..."

  # ==================== JOB 7: NOTIFICATIONS ====================
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [security-scan, unit-integration-tests, build-docker, e2e-tests, deploy-stage, deploy-prod]
    if: always()
    steps:
      - name: Determine status
        id: status
        run: |
          if [ "${{ needs.security-scan.result }}" == "failure" ] || \
             [ "${{ needs.unit-integration-tests.result }}" == "failure" ] || \
             [ "${{ needs.build-docker.result }}" == "failure" ] || \
             [ "${{ needs.e2e-tests.result }}" == "failure" ]; then
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=Pipeline failed. Check the logs for details." >> $GITHUB_OUTPUT
          else
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=Pipeline completed successfully!" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack Notification (via webhook)
        if: always() && env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ env.SLACK_WEBHOOK_URL }}
        run: |
          cat << 'EOF' > slack_payload.json
          {
            "text": "${{ steps.status.outputs.status == 'failure' && 'ðŸš¨ Pipeline Failed' || 'âœ… Pipeline Succeeded' }}",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*${{ steps.status.outputs.status == 'failure' && 'ðŸš¨ Pipeline Failed' || 'âœ… Pipeline Succeeded' }}*\n\nRepository: ${{ github.repository }}\nBranch: ${{ github.ref_name }}\nCommit: <${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}|${{ github.sha }}>\nAuthor: ${{ github.actor }}\n\n${{ steps.status.outputs.message }}"
                }
              },
              {
                "type": "actions",
                "elements": [
                  {
                    "type": "button",
                    "text": {
                      "type": "plain_text",
                      "text": "View Run"
                    },
                    "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }
                ]
              }
            ]
          }
          EOF

          echo "Calling Slack webhook: $SLACK_WEBHOOK_URL"
          curl -v -X POST \
            -H 'Content-type: application/json' \
            --data @slack_payload.json \
            "$SLACK_WEBHOOK_URL"

      - name: Create GitHub Issue on failure
        if: steps.status.outputs.status == 'failure' && env.ISSUE_TOKEN != ''
        uses: actions/github-script@v7
        env:
          ISSUE_TOKEN: ${{ env.ISSUE_TOKEN }}
        with:
          github-token: ${{ env.ISSUE_TOKEN }}
          script: |
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸš¨ Pipeline Failed: ${context.ref} - ${context.sha.substring(0, 7)}`,
              body: `Pipeline failed for commit ${context.sha}\n\n**Branch:** ${context.ref}\n**Author:** ${context.actor}\n**Workflow:** ${context.workflow}\n\n**Failed Jobs:**\n- Security Scan: ${{ needs.security-scan.result }}\n- Tests: ${{ needs.unit-integration-tests.result }}\n- Build: ${{ needs.build-docker.result }}\n- E2E: ${{ needs.e2e-tests.result }}\n\n[View Run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`,
              labels: ['bug', 'ci/cd']
            })
